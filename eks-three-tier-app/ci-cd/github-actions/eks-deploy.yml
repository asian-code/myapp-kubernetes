# CI/CD Pipeline for EKS Three-Tier Application
# This workflow handles building, testing, and deploying the application

name: EKS Three-Tier App CI/CD

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'app-src/**'
      - 'k8s-manifests/**'
      - 'terraform/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'app-src/**'
      - 'k8s-manifests/**'
      - 'terraform/**'

env:
  AWS_REGION: us-west-2
  EKS_CLUSTER_NAME: three-tier-eks-cluster
  ECR_REPOSITORY_FRONTEND: three-tier-app/frontend
  ECR_REPOSITORY_BACKEND: three-tier-app/backend
  ENVIRONMENT: production

jobs:
  # Security and Code Quality Checks
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

    - name: Run Checkov static analysis
      uses: bridgecrewio/checkov-action@master
      with:
        directory: .
        framework: terraform,kubernetes,dockerfile
        output_format: sarif
        output_file_path: checkov-results.sarif

  # Terraform Plan and Validate
  terraform-validate:
    name: Terraform Validate
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.x

    - name: Terraform Format Check
      run: terraform fmt -check -recursive

    - name: Terraform Init
      run: terraform init -backend=false

    - name: Terraform Validate
      run: terraform validate

    - name: Run tflint
      uses: terraform-linters/setup-tflint@v3
      with:
        tflint_version: v0.44.1
    - run: tflint --init
      working-directory: terraform
    - run: tflint
      working-directory: terraform

  # Build and Test Applications
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: [security-scan]
    strategy:
      matrix:
        app: [frontend, backend]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build image
        docker build \
          -t $ECR_REGISTRY/${{ matrix.app == 'frontend' && env.ECR_REPOSITORY_FRONTEND || env.ECR_REPOSITORY_BACKEND }}:$IMAGE_TAG \
          -t $ECR_REGISTRY/${{ matrix.app == 'frontend' && env.ECR_REPOSITORY_FRONTEND || env.ECR_REPOSITORY_BACKEND }}:latest \
          app-src/${{ matrix.app }}
        
        # Run security scan on image
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy image --exit-code 1 --severity HIGH,CRITICAL \
          $ECR_REGISTRY/${{ matrix.app == 'frontend' && env.ECR_REPOSITORY_FRONTEND || env.ECR_REPOSITORY_BACKEND }}:$IMAGE_TAG
        
        # Push image
        docker push $ECR_REGISTRY/${{ matrix.app == 'frontend' && env.ECR_REPOSITORY_FRONTEND || env.ECR_REPOSITORY_BACKEND }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ matrix.app == 'frontend' && env.ECR_REPOSITORY_FRONTEND || env.ECR_REPOSITORY_BACKEND }}:latest

    - name: Run application tests
      if: matrix.app == 'backend'
      run: |
        # Run unit tests for backend
        cd app-src/backend
        npm ci
        npm run test
        npm run test:coverage

    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always() && matrix.app == 'backend'
      with:
        name: test-results
        path: app-src/backend/coverage/

  # Infrastructure Deployment (Terraform)
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [terraform-validate, security-scan]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    defaults:
      run:
        working-directory: terraform
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.x

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      run: terraform init

    - name: Terraform Plan
      run: terraform plan -var-file="terraform.tfvars" -out=tfplan

    - name: Terraform Apply
      run: terraform apply -auto-approve tfplan

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

  # Application Deployment (Kubernetes)
  deploy-applications:
    name: Deploy Applications
    runs-on: ubuntu-latest
    needs: [build-and-test, deploy-infrastructure]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Validate Kubernetes manifests
      run: |
        # Validate all Kubernetes YAML files
        find k8s-manifests -name "*.yaml" -exec kubectl apply --dry-run=client --validate=true -f {} \;

    - name: Deploy namespace configurations
      run: |
        # Create namespaces if they don't exist
        kubectl create namespace frontend --dry-run=client -o yaml | kubectl apply -f -
        kubectl create namespace backend --dry-run=client -o yaml | kubectl apply -f -
        kubectl create namespace database --dry-run=client -o yaml | kubectl apply -f -
        kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy security configurations
      run: |
        kubectl apply -f k8s-manifests/security/

    - name: Deploy database
      run: |
        kubectl apply -f k8s-manifests/database/
        # Wait for database to be ready
        kubectl rollout status statefulset/postgresql -n database --timeout=300s

    - name: Update and deploy backend
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Update image in backend deployment
        sed -i "s|image: node:18-alpine|image: $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG|g" k8s-manifests/backend/backend-api.yaml
        kubectl apply -f k8s-manifests/backend/
        # Wait for backend to be ready
        kubectl rollout status deployment/backend-api -n backend --timeout=300s

    - name: Update and deploy frontend
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Update image in frontend deployment
        sed -i "s|image: nginx:1.25-alpine|image: $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG|g" k8s-manifests/frontend/frontend-web.yaml
        kubectl apply -f k8s-manifests/frontend/
        # Wait for frontend to be ready
        kubectl rollout status deployment/frontend-web -n frontend --timeout=300s

    - name: Deploy monitoring
      run: |
        kubectl apply -f k8s-manifests/monitoring/
        # Wait for monitoring to be ready
        kubectl rollout status deployment/prometheus -n monitoring --timeout=300s
        kubectl rollout status deployment/grafana -n monitoring --timeout=300s

    - name: Run smoke tests
      run: |
        # Wait for all pods to be ready
        kubectl wait --for=condition=ready pod -l app=frontend-web -n frontend --timeout=300s
        kubectl wait --for=condition=ready pod -l app=backend-api -n backend --timeout=300s
        kubectl wait --for=condition=ready pod -l app=postgresql -n database --timeout=300s

        # Get load balancer URL
        echo "Waiting for load balancer to be ready..."
        sleep 60
        
        # Basic health checks
        kubectl get pods -A
        kubectl get services -A
        kubectl get ingress -A

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "✅ Deployment successful!"
        else
          echo "❌ Deployment failed!"
          kubectl get events --sort-by=.metadata.creationTimestamp -A
        fi

  # Rollback on failure
  rollback-on-failure:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-applications]
    if: failure() && github.ref == 'refs/heads/main'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Rollback deployments
      run: |
        echo "Rolling back deployments..."
        kubectl rollout undo deployment/frontend-web -n frontend
        kubectl rollout undo deployment/backend-api -n backend
        
        # Wait for rollback to complete
        kubectl rollout status deployment/frontend-web -n frontend --timeout=300s
        kubectl rollout status deployment/backend-api -n backend --timeout=300s
        
        echo "Rollback completed!"

  # Performance and Load Testing (Optional)
  performance-test:
    name: Performance Test
    runs-on: ubuntu-latest
    needs: [deploy-applications]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get Application URL
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        APP_URL=$(kubectl get ingress frontend-web-ingress -n frontend -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        echo "APP_URL=https://$APP_URL" >> $GITHUB_ENV

    - name: Run load tests with k6
      uses: grafana/k6-action@v0.2.0
      with:
        filename: tests/load-test.js
      env:
        APP_URL: ${{ env.APP_URL }}

    - name: Upload performance results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: performance-results
        path: k6-results.json
